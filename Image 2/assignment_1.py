# -*- coding: utf-8 -*-
"""Fall 2024 AIN433 Assignment 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ap_5R3qIdS8EMmj9HgoLk0Iv0z-363zT

#Fall 2024 AIN433 Assignment 1
**Student:** Mehmet Ertaş - 2200765035

**Instructor:** Ali Seydi Keçeli

**TA:** Sibel Kapan

#Imports and Data Load
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.ndimage import convolve
import cv2
import os
from tqdm import tqdm
from sklearn.naive_bayes import GaussianNB
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from skimage import filters

from google.colab import drive
drive.mount('/content/drive')

"""##Loading Data"""

labels = ['street', 'sea', 'mountain', 'glacier', 'forest', 'buildings']
X_train = []
y_train = []
X_test = []
y_test = []

for i in labels:
    folderPath = os.path.join('/content/drive/My Drive/intel_image_dataset/train/',i)
    for j in tqdm(os.listdir(folderPath)):
        img = cv2.imread(os.path.join(folderPath,j))
        X_train.append(img)
        y_train.append(i)

for i in labels:
    folderPath = os.path.join('/content/drive/My Drive/intel_image_dataset/test/',i)
    for j in tqdm(os.listdir(folderPath)):
        img = cv2.imread(os.path.join(folderPath,j))
        X_test.append(img)
        y_test.append(i)

"""#Functions

##Base Image Altering Functions
"""

def grayscale(image):
    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

"""##Gradient Filtering Functions

###Sobel Filter
"""

#A function that returns gradX and gradY: two arrays that shows the x and y gradients of given image
def sobelFilter(image):
  #Sobel filters for X and Y gradients
    sobelX = np.array([[-1, 0, 1],
                       [-2, 0, 2],
                       [-1, 0, 1]])

    sobelY = np.array([[-1, -2, -1],
                       [ 0,  0,  0],
                       [ 1,  2,  1]])

    #Filtering the image using X and Y filters
    gradX = convolve(image, sobelX)
    gradY = convolve(image, sobelY)

    return gradX, gradY

"""###Prewitt Filter"""

#A function that returns gradX and gradY: two arrays that shows the x and y gradients of given image
def prewittFilter(image):
    #Previtt filters for X and Y gradients
    prewittX = np.array([[ -1, 0, 1],
                         [ -1, 0, 1],
                         [ -1, 0, 1]])

    prewittY = np.array([[  1, 1, 1],
                         [  0, 0, 0],
                         [ -1, -1, -1]])

    #Filtering the image using X and Y filters
    gradX = convolve(image, prewittX)
    gradY = convolve(image, prewittY)

    return gradX, gradY

"""##Magnitude and Orientation finding Function

![1_w3Uo3WUwnbpgmNOZHRKvpA.webp](data:image/webp;base64,UklGRrILAABXRUJQVlA4WAoAAAAIAAAA2gAAkwAAVlA4INIKAAAwNgCdASrbAJQAPm0ylUckIyIhKTWaoIANiWlu3WBou//vHhr4zfO3tb/budpz9/e/Qn+Pfbn8V7Gux/4gagX5J/Pf9FvSs2HqC+6P3fwIdUrvv/zPcC/nP9l42ugL4qn/N/q/Vv9Qf930yS6QbDHZcQNFpv2eQUgAV/7H5f8ntpyWN2aEqxL1uMGHbD6Q6MkUxIKT9cxwDe7wuAJOtHk97FST1aHUjQc29K+STWg9/nf4FOBKCMe3GORbm9AK91DECpZwAYmFPq5hbpVCBYu5GHA2/70C+Z9a3FOKF+Re+xighk1aAwYMkWbNqAKyb0YYHeW8I+kR+w/TZDvBPgkZWZBHiegK6Zo0oB60OG3WfBraPXEPZcBYM0ZkLgj6UFM4nuJMOWAVn3ptynFiTmudMqwR0Ge+9UHPCyPA5PkW+HWfwegzCtKbFesXAOtsx79tmKnFMStyZ/hw013XoPHnbw3bq/ZDRfmzPlyWA+Uwat3um8k1zOt2eLtUJPQBkuSkADoDKr8kSOAdI+pHxOIuXeAAgsHgswNzZ/P5/WkqAq0P2J21Eo6KJOVJFq5iB3aa5DuDYbAJFEGAAP78qB6Buz4+J7TcUaFgyoSoMtTP3vK22CeE13KxFtSCOhHT9RYpo4Mutl3HiPJ0CswQ97o5pgtwLxtuFNVKk7C+e31VO9vYyzPvZbUhxjhpEAzkvN2OS8JosmURlXxbOjSptJVp846eMyvgB5rd82P4m6iNzRLgVlZJHD/zVa81mGFO9pT/DrHldHFgSHj9P3bYdamsa7mgaddwTNojannz/Fetum22zqXvmNJtlCRqbfjkYYLa+jGX9cefUBTwaqqXgvkzBv5bEjiLBfyqTmne03/eTCZ0Y+Bv1a6F+S2F/d3imzxlsioUCPG4P/zXaD1rstUsXgPWNm0vFrNEcP2sbqJNylAmXOGtud1exWRQnqR01Nk/sI/9fZG8fXvbjkreIJpXM5pmgbnnkWMtri3R4SeV7nA/WESSZrjHtqpJ3Jum2GCauRjmbM5Xfvc/LAXIt7r/6aSwUnGhPwhKIg1d+njwvhIndUESntEKcxNhS/c4Ni33nYOeijP9G70vz6sCn4MlAANBXkOYl6Sxxj3ikDt1Ye3DvxpNyGFoOOYkI6RtzXeCWFglfgRYypbfPfKm8U8Krsg7csq3m/ZsbkiIOsP9S+kiA6MvjXCcUDjHXIGCQmM5NoCMf1PEaJzAlmnHC2LMTLlg5li6N4Q1w7rFzZ22XEsInVhdigEPrqpzf1I8dM6v2kjr/ql95y/11vbo9zXhbJ/Jd1eFK6SgxtoWwRQfRPGfrPmvvPDQr9uEPcWM3KB0iltil/i+qrv2+yutHm6E0UT/pqBwGwaEl7A+C5ZX5/sn9+30KvNwXAa74ka0IiPU4m1IzE5D/QGng/89RnxWwapuhVt15Q5HkvxMSsDqzhrq7Kf+32qs+adnuZDqLnVPdnEpTX2VznPLbSErGMsa9s0bXaxuSmaicuo9rTmR75UjqofgL81dQVg2SkTMwBtTUdL6r8Pk3sUD/pUjDxtN66sX6i163IHTi/7J47PKZ/FGXbOJHzP30qm1/R9mt469+WqZAcgBOoG4YztkDmzui8IuaqJHa3adVAYYPAtRDYhGRbA3LB/LjWL4K88AXJfe20eB6szq3TDuj5Yrb5coCPmCsv7ufOwlHuzAH2RZ30ckNiagfchu3pMViaVpU9Me6zmIcrzQZulmIVxnZIfqy2PgnRwckmGG810+C3juPBYnn6JAfYRFRbnQJqvf3BX1qRhmInt/4H1kV2Cz/mEtHc1pHpfOSGgKYWf2ZCrt2HqyibggdktKgI9/xsP6+BfvCaXyhXkgCvLw/vAEUUvP5XxMqVQ2MSCP9xRW2V8TjzkgOvFRVMyapngUeWeNvpDMOHWEO6SSddcAO8KpBXHDzgRQIDygzHoNK7HYr4sSUUqeqGF/ij02KKIhlExoEKbciQISLKh8SLoGP8M6gx8I7SPFNGLZwlru6eU/zwpgC2xxnKFArmmo+/cqEp04h9kdOhA9js+dlk8x5f9nkdCrxodZu/2qVLSrK8IBlkCodLMSyujxkcsCiIGeE9itGYjKoqciRW5PpSBUojg1UWIEhWfWO2G6Y5M/JrI5KpcPrJxAEhCbTvzf5Yszl0N70wHu4CUr9dxb7q79FX/Znf/Op9DcysxsSDvF1Ib1TRJzVS2Ikndqc7aXf2sBmDsfVw12pkCF15NiGtGmK43uNzkGE22Nt4+ufqXVRJVU7nyVeh8yGW0f9JXxvel81LfKJholV1EQ11j+u40AQ6XdggvVIv8LllzyfivVsw3bDk7Yey/3pSAn94RdNvVvAp0WWcEqvbg1ArEXK8K/h1u3hXjiA2u09Cfbbsp8okuzf6xAwPdT3JixTsVsjAEIqsfEYiev3nUx2Dk/vxL1p7XQ2/G+nIZgMAopNO86AQC/UUhnpZUWvgMHeIom0dLG4kQ59hVvQxRl11lngRmkdATMb0vU7ucvng49VcwC47aDlKpb0UHO2BlUl4Sb1A/XgxfzhLlQDc6Tvrb+kRkLVw/8/Ch8qUQ769FR5o/CUnWzY3jP2dIAiyYe1fGcggNGIZBIuHvmDMLNeVDwYkl6XxKHsbqh0JgMud7Epa1+kEMf0+76n/K2C3Hb/XJfl5+PzvoPc7FRr57eekfUMOsA0XB/Hkx+xY/sZYT1K0nqlbWUucvQsanQIBWlQ2GOK/3ToMQtKtvwNVPAtfWm5JGxLdcrEYAS7XVSY4/u521eP3NLd6/sNCnhHr3H+s4SNJKxgULmrraptJYMRrZcB4kqpqz4klF+GxSWJXtwQHwU1OsP/DOpVSACguD6cYU07hOzYLOn9h+B7lTMDx//gKVGqWaATw0Rckw/nlU7Wq9mZHiE2i+OhTmqRV8ZrK5CpVjgrzZ5c1eGxIzPkpFt1gmwV3GdrGK2mnfwyjMZ91XvU/FteniVgR45Dblu+W893Jiq90uj7Pnt6SnZLGLHtztQdK6UosnAQvXpo25fY0QZqx2NIdhmKMSX3Vr+HNhxZS/O3DUoJZqnwzCt/Y/4Y3T79nr76CL6owlLC66OWx8VFx/g5G5zJ0vgzD6qIFu/cusf7BAq47Csdw/IdPg0uiK4lR9EP7turoySkHr9YU/RMrtnJ54KYZvfWkDheUFJZJPtzrsm49QI4VQENFtEACo/gloF6rGPSJBOPEtjW+/rlrPLfteTGqqEYYpJu3/9SkZD3AU6EgPrp+sFUE3OO3lGEVuyfm3EsQPBEJMU46PFiW2x4blMuIn9KuvZL5BTje7WuEyLgl0+zX4jKgdI4aSFF5u6hu+mVRt5bXGmVQsm3R+BQNUKLxftamf4HgEPjJlXbWLqlGwI0Uo1kJ3DdRm1Byhgh0x0/Rm0uZ7bEw/UcG1d2XIda0aFT9kgqh37F2SK3bWbdTK/RKZOnK3XQjv6d0JPv3hJyjJgtf5KSMpma2fsuYGZMAvwvQbg6p0ODcx5zqOXqh3mxe/I2hd/FnGzb7k3/jV22i1FETidkjW+19jXrargfAw9dIvxBPdD3fsHHORRjD6H2iWPgr+GBjnqdiaC87y4mBfggSA+Zp9AfzLJWBVh3eAtbP4bwoVbJrRy87Dc9zsVzUw4c/4Aa/uB8CWallG9aPrHw+5X5zMXL/uIR3WAAAAARVhJRroAAABFeGlmAABJSSoACAAAAAYAEgEDAAEAAAABAAAAGgEFAAEAAABWAAAAGwEFAAEAAABeAAAAKAEDAAEAAAACAAAAEwIDAAEAAAABAAAAaYcEAAEAAABmAAAAAAAAAEgAAAABAAAASAAAAAEAAAAGAACQBwAEAAAAMDIxMAGRBwAEAAAAAQIDAACgBwAEAAAAMDEwMAGgAwABAAAA//8AAAKgBAABAAAA2wAAAAOgBAABAAAAlAAAAAAAAAA=)
"""

#A function that returns magnitude and orientation given X and Y gradients of an image
def magAndOri(gradX,gradY):
    mag = np.sqrt(gradX ** 2 + gradY ** 2)

    ori = np.rad2deg(np.arctan2(gradY, gradX)) % 180

    return mag, ori

"""##Grid Dividing Function"""

#A function that divides the image into Row x Col grid and returns them in an array
def gridDivider(image, gridRow = 4, gridCol = 4):
    h, w = image.shape
    gridH, gridW = h // gridRow, w // gridCol #By default it is 4x4 grid

    grids = []
    for i in range(gridRow):
        for j in range(gridCol):
            grid = image[i*gridH:(i+1)*gridH, j*gridW:(j+1)*gridW]
            grids.append(grid)

    return grids

"""##Histogram Functions

###Histogram Plotter
"""

#A function that returns the histogram of given image based on the angle of the orientation.
def compute_histograms(mag, ori, num_bins=9):
    h, w = mag.shape
    bin_width = 180 / num_bins
    histogram = np.zeros(num_bins)

    for i in range(h):
        for j in range(w):
            angle = ori[i, j]
            bin_idx = int(angle // bin_width)
            histogram[bin_idx] += mag[i, j]

    return histogram

"""###Histogram Normalizing and Rotatoing Functions"""

#A function that returns normalized histogram
def normalize_histogram(histogram):
    norm = np.linalg.norm(histogram)
    return histogram / (norm + 1e-6)

#A function that returns rotated histogram where the maximum gradient is at start
#While the pdf says to put it in middle, the figures showed it at the start so I used that as a base.
def rotate_histogram(histogram):
    max_bin_index = np.argmax(histogram)
    return np.roll(histogram, -max_bin_index)

"""##HoG Function"""

#A function that returns 1d vector that is usable by logistic regression or naive bayes classifier
def compute_hog_features(image, target =(1024,1024), gridRow = 4, gridCol = 4, filter_type='sobel'):
  #Turning it grayscale
  grayImage = grayscale(image)

  #Dividing into grids
  grids = gridDivider(grayImage, gridRow, gridCol)

  histograms = []
  for grid in grids:
    if filter_type == 'sobel':
      gradX, gradY = sobelFilter(grid)
    elif filter_type == 'prewitt':
      gradX, gradY = prewittFilter(grid)
    mag, ori = magAndOri(gradX, gradY)

    histogram = compute_histograms(mag, ori)
    normalized_hist = normalize_histogram(histogram)  #Normalize histogram
    rotated_hist = rotate_histogram(normalized_hist)  #Rotate histogram
    histograms.append(rotated_hist)

  return np.concatenate(histograms)  #Return a 1d vector so that we can use it later

"""#3x3 Grid Tests

##Sobel
"""

x_train_hog_3s = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 3, gridCol = 3, filter_type='sobel')
    x_train_hog_3s.append(hog_features)

x_test_hog_3s = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 3, gridCol = 3, filter_type='sobel')
    x_test_hog_3s.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_3s, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_3s)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_3s, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_3s)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""##Prewitt"""

x_train_hog_3p = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 3, gridCol = 3, filter_type='prewitt')
    x_train_hog_3p.append(hog_features)

x_test_hog_3p = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 3, gridCol = 3, filter_type='prewitt')
    x_test_hog_3p.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_3p, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_3p)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_3p, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_3p)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""#4x4 Grid Tests

##Sobel
"""

x_train_hog_4s = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 4, gridCol = 4, filter_type='sobel')
    x_train_hog_4s.append(hog_features)

x_test_hog_4s = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 4, gridCol = 4, filter_type='sobel')
    x_test_hog_4s.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_4s, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_4s)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_4s, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_4s)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""##Prewitt"""

x_train_hog_4p = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 4, gridCol = 4, filter_type='prewitt')
    x_train_hog_4p.append(hog_features)

x_test_hog_4p = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 4, gridCol = 4, filter_type='prewitt')
    x_test_hog_4p.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_4p, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_4p)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_4p, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_4p)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""#5x5 Grid Tests

##Sobel
"""

x_train_hog_5s = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 5, gridCol = 5, filter_type='sobel')
    x_train_hog_5s.append(hog_features)

x_test_hog_5s = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 5, gridCol = 5, filter_type='sobel')
    x_test_hog_5s.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_5s, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_5s)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_5s, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_5s)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""##Prewitt"""

x_train_hog_5p = []
for img in tqdm(X_train):
    hog_features = compute_hog_features(img, gridRow = 5, gridCol = 5, filter_type='prewitt')
    x_train_hog_5p.append(hog_features)

x_test_hog_5p = []
for img in tqdm(X_test):
    hog_features = compute_hog_features(img, gridRow = 5, gridCol = 5, filter_type='prewitt')
    x_test_hog_5p.append(hog_features)

naive_bayes_classifier = GaussianNB()
naive_bayes_classifier.fit(x_train_hog_5p, y_train)
y_pred_nb = naive_bayes_classifier.predict(x_test_hog_5p)
accuracy_nb = accuracy_score(y_test, y_pred_nb)
print(f'Naive Bayes Accuracy: {accuracy_nb:.2f}')

logistic_regression_classifier = LogisticRegression(max_iter=1000)
logistic_regression_classifier.fit(x_train_hog_5p, y_train)
y_pred_lr = logistic_regression_classifier.predict(x_test_hog_5p)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print(f'Logistic Regression Accuracy: {accuracy_lr:.2f}')

"""#Report

In this assignment we were tasked to write our own Histogram of Gradient function and use that to classify different pictures.

In order to have a clean code I started with dividing the HoG transform into several smaller steps. Then I made each of them seperate functions before combining them into one HoG function. This allowed me to make changes easier.

For the grid dividing function I made it so that we can seperate the grid into 4x5 or 6x3 allowing me have more control over my grid. Since the size of the each grid is dynamically adjusted I didn't resize my pictures beforehand. I compared between 3x3, 4x4, 5x5 grids. Bigger grids produced better results but also longer to compute.

I used Sobel and Prewitt filters to compare against each other. Prewitt filter provided better results even though both were about 50% accuracy. With equal computing times.
"""